{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst {\n  FileCoverage\n} = require('./file-coverage');\nconst {\n  CoverageSummary\n} = require('./coverage-summary');\nfunction maybeConstruct(obj, klass) {\n  if (obj instanceof klass) {\n    return obj;\n  }\n  return new klass(obj);\n}\nfunction loadMap(source) {\n  const data = Object.create(null);\n  if (!source) {\n    return data;\n  }\n  Object.entries(source).forEach(_ref => {\n    let [k, cov] = _ref;\n    data[k] = maybeConstruct(cov, FileCoverage);\n  });\n  return data;\n}\n\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\nclass CoverageMap {\n  /**\n   * @constructor\n   * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n   * map's contents. This can be the raw global coverage object.\n   */\n  constructor(obj) {\n    if (obj instanceof CoverageMap) {\n      this.data = obj.data;\n    } else {\n      this.data = loadMap(obj);\n    }\n  }\n\n  /**\n   * merges a second coverage map into this one\n   * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n   *  correctly for the same files and additional file coverage keys are created\n   *  as needed.\n   */\n  merge(obj) {\n    const other = maybeConstruct(obj, CoverageMap);\n    Object.values(other.data).forEach(fc => {\n      this.addFileCoverage(fc);\n    });\n  }\n\n  /**\n   * filter the coveragemap based on the callback provided\n   * @param {Function (filename)} callback - Returns true if the path\n   *  should be included in the coveragemap. False if it should be\n   *  removed.\n   */\n  filter(callback) {\n    Object.keys(this.data).forEach(k => {\n      if (!callback(k)) {\n        delete this.data[k];\n      }\n    });\n  }\n\n  /**\n   * returns a JSON-serializable POJO for this coverage map\n   * @returns {Object}\n   */\n  toJSON() {\n    return this.data;\n  }\n\n  /**\n   * returns an array for file paths for which this map has coverage\n   * @returns {Array{string}} - array of files\n   */\n  files() {\n    return Object.keys(this.data);\n  }\n\n  /**\n   * returns the file coverage for the specified file.\n   * @param {String} file\n   * @returns {FileCoverage}\n   */\n  fileCoverageFor(file) {\n    const fc = this.data[file];\n    if (!fc) {\n      throw new Error(`No file coverage available for: ${file}`);\n    }\n    return fc;\n  }\n\n  /**\n   * adds a file coverage object to this map. If the path for the object,\n   * already exists in the map, it is merged with the existing coverage\n   * otherwise a new key is added to the map.\n   * @param {FileCoverage} fc the file coverage to add\n   */\n  addFileCoverage(fc) {\n    const cov = new FileCoverage(fc);\n    const {\n      path\n    } = cov;\n    if (this.data[path]) {\n      this.data[path].merge(cov);\n    } else {\n      this.data[path] = cov;\n    }\n  }\n\n  /**\n   * returns the coverage summary for all the file coverage objects in this map.\n   * @returns {CoverageSummary}\n   */\n  getCoverageSummary() {\n    const ret = new CoverageSummary();\n    Object.values(this.data).forEach(fc => {\n      ret.merge(fc.toSummary());\n    });\n    return ret;\n  }\n}\nmodule.exports = {\n  CoverageMap\n};","map":{"version":3,"names":["FileCoverage","require","CoverageSummary","maybeConstruct","obj","klass","loadMap","source","data","Object","create","entries","forEach","k","cov","CoverageMap","constructor","merge","other","values","fc","addFileCoverage","filter","callback","keys","toJSON","files","fileCoverageFor","file","Error","path","getCoverageSummary","ret","toSummary","module","exports"],"sources":["C:/Users/szymo/OneDrive/Pulpit/Programowanie/Kurs tworzenia stron/NewReact/ReactMeals/node_modules/istanbul-lib-coverage/lib/coverage-map.js"],"sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst { FileCoverage } = require('./file-coverage');\nconst { CoverageSummary } = require('./coverage-summary');\n\nfunction maybeConstruct(obj, klass) {\n    if (obj instanceof klass) {\n        return obj;\n    }\n\n    return new klass(obj);\n}\n\nfunction loadMap(source) {\n    const data = Object.create(null);\n    if (!source) {\n        return data;\n    }\n\n    Object.entries(source).forEach(([k, cov]) => {\n        data[k] = maybeConstruct(cov, FileCoverage);\n    });\n\n    return data;\n}\n\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\nclass CoverageMap {\n    /**\n     * @constructor\n     * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n     * map's contents. This can be the raw global coverage object.\n     */\n    constructor(obj) {\n        if (obj instanceof CoverageMap) {\n            this.data = obj.data;\n        } else {\n            this.data = loadMap(obj);\n        }\n    }\n\n    /**\n     * merges a second coverage map into this one\n     * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n     *  correctly for the same files and additional file coverage keys are created\n     *  as needed.\n     */\n    merge(obj) {\n        const other = maybeConstruct(obj, CoverageMap);\n        Object.values(other.data).forEach(fc => {\n            this.addFileCoverage(fc);\n        });\n    }\n\n    /**\n     * filter the coveragemap based on the callback provided\n     * @param {Function (filename)} callback - Returns true if the path\n     *  should be included in the coveragemap. False if it should be\n     *  removed.\n     */\n    filter(callback) {\n        Object.keys(this.data).forEach(k => {\n            if (!callback(k)) {\n                delete this.data[k];\n            }\n        });\n    }\n\n    /**\n     * returns a JSON-serializable POJO for this coverage map\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * returns an array for file paths for which this map has coverage\n     * @returns {Array{string}} - array of files\n     */\n    files() {\n        return Object.keys(this.data);\n    }\n\n    /**\n     * returns the file coverage for the specified file.\n     * @param {String} file\n     * @returns {FileCoverage}\n     */\n    fileCoverageFor(file) {\n        const fc = this.data[file];\n        if (!fc) {\n            throw new Error(`No file coverage available for: ${file}`);\n        }\n        return fc;\n    }\n\n    /**\n     * adds a file coverage object to this map. If the path for the object,\n     * already exists in the map, it is merged with the existing coverage\n     * otherwise a new key is added to the map.\n     * @param {FileCoverage} fc the file coverage to add\n     */\n    addFileCoverage(fc) {\n        const cov = new FileCoverage(fc);\n        const { path } = cov;\n        if (this.data[path]) {\n            this.data[path].merge(cov);\n        } else {\n            this.data[path] = cov;\n        }\n    }\n\n    /**\n     * returns the coverage summary for all the file coverage objects in this map.\n     * @returns {CoverageSummary}\n     */\n    getCoverageSummary() {\n        const ret = new CoverageSummary();\n        Object.values(this.data).forEach(fc => {\n            ret.merge(fc.toSummary());\n        });\n\n        return ret;\n    }\n}\n\nmodule.exports = {\n    CoverageMap\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}